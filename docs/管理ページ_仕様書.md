# 管理ページ 仕様書

この仕様書は `admin-site` とそれに関わる API / 配信経路（Cloudflare Worker、public worker、Supabase、R2/Images 等）に関する詳細な仕様をまとめたものです。実装者・運用者が参照できるように、機能の種類、API エンドポイント、ペイロード、Cookie／認証挙動、配信方法、デプロイ要件、トラブルシュートを含みます。

**対象リポジトリ内ファイル**: `admin-site/*`, `cloudflare/admin-api-proxy/*`, `public-worker/*`（存在する場合）

---

**目次**
- **機能一覧**
- **API エンドポイント一覧（HTTP メソッド・ペイロード）**
- **認証・Cookie の仕様**
- **画像（アップロード・保存・配信）仕様**
- **配信／デプロイ構成**
- **実装上の注意点・運用チェックリスト**
- **トラブルシュート**

---

**機能一覧**
- ユーザー認証（Google OAuth を含む Supabase 認証）
- サーバ側 whoami による管理 UI のガード（サーバ権威）
- 画像アップロード（直接署名付き PUT とプロキシ経由のフェールバック）
- 画像メタデータ保存（DB にはキーのみ保存）
- 管理用 CRUD API（タグ・コレクション・ページ・製品等）
- 管理 UI の静的配信（Pages / CDN）
- 管理向け API を public-worker へフォワードする Worker プロキシ
- 必要に応じた Supabase REST フォールバック（Worker 内での読み取り）

---

**API エンドポイント一覧（代表）**
以下は admin 側で主に利用するエンドポイントの設計（現在の実装に基づく想定）。実装に差異がある場合は適宜合わせてください。

- **認証系**
  - `GET /api/auth/whoami`
    - 機能: クライアントの HttpOnly Cookie（`sb-access-token`）を使って現在のユーザ情報を返す
    - リクエスト: `credentials: 'include'`, `cache: 'no-store'`
    - レスポンス: 200 + JSON `{ id, email, aud, role, ... }` / 401 未認証
  - `POST /api/auth/set_tokens`
    - 機能: OAuth 断片受取やサーバ側コード交換結果を受け取り、HttpOnly Cookie を発行する
    - リクエスト: JSON または form-encoded body で `{ access_token, refresh_token, expires_at?, provider_token? }`
    - レスポンス: 204 または 200（`Set-Cookie` ヘッダを含む）
  - `GET /api/auth/google` と `GET /api/auth/callback`
    - 機能: Google 認可エンドポイントへリダイレクト／コールバック処理。コード交換してトークンを取得する。
    - コールバックがフラグメント（#access_token=...）で返る場合はフラグメント捕捉用 HTML を返し、その HTML が `POST /api/auth/set_tokens` にトークンを送る。

- **画像系**
  - `POST /api/images/direct-upload`
    - 機能: 署名付きアップロード URL を生成して返す（PUT 用 URL）
    - リクエスト: `{ filename, contentType, metadata? }`
    - レスポンス: 200 `{ uploadURL, key }`
  - `POST /api/images/upload` (proxy)
    - 機能: ブラウザからファイルを受け取り Worker もしくは public-worker 経由で保存（フェールバック）
    - リクエスト: `multipart/form-data`（file）
    - レスポンス: 200 `{ key, url? }`
  - `POST /api/images/complete`
    - 機能: 署名アップロード完了後にメタ情報を DB に保存して確定する
    - リクエスト: `{ key, width?, height?, variants? }`
    - レスポンス: 200 `{ ok: true, id? }`

- **管理 CRUD（例）**
  - `GET /api/admin/settings` — サイト設定の取得
  - `PUT /api/admin/settings` — サイト設定の保存
  - `GET /api/admin/tags` — タグ一覧
  - `POST /api/admin/tags` — タグ作成
  - `PATCH /api/admin/tags/:id` — タグ更新
  - `DELETE /api/admin/tags/:id` — タグ削除
  - これらはすべて `credentials: 'include'` を前提に呼ばれる（管理 UI からは `apiFetch()` を通して呼ぶ）

- **プロキシ挙動（Worker）**
  - Worker は `admin.shirasame.com/api/*` を受け取り、内部ロジックで
    1. 可能なら public-worker の同パス（`/api/...` をそのまま含むか、`/api` を除いたパスのどちらか）にフォワード
    2. 公開先に存在しない場合、Supabase の REST エンドポイントを使って読み取りを実行する（主に GET）
  - Worker は `/api/auth/*` を自前で処理する（set_tokens, whoami, google callback 等）

---

**認証・Cookie の仕様**
- Cookie 名称
  - `sb-access-token` — Supabase のアクセストークン（短期）
  - `sb-refresh-token` — リフレッシュトークン（長期）
- セキュリティ属性（推奨）
  - `HttpOnly; Secure; Path=/; Domain=admin.shirasame.com; SameSite=Lax`
    - 理由: 管理サイトは同一オリジンのブラウザ呼び出しでのみ cookie を送るが、OAuth のリダイレクト時の挙動を考慮し `Lax` が一般的で安全だが、もしクロスサイトPOSTで cookie を送る必要があるなら `SameSite=None; Secure` が必要。
  - `Expires` / `Max-Age` はトークンの寿命に合わせる
- クライアント側呼び出し
  - 管理 UI は `admin-site/lib/api-client.ts` の `apiFetch()` を使う。`apiFetch()` は既定で `{ credentials: 'include', redirect: 'manual' }` を与える。
  - 401 を返された場合、クライアントは `/admin/login` へ遷移（または適切なログアウト処理）する実装になっている。
- OAuth フローのふた通り
  - サーバ側コード交換
    - `GET /api/auth/callback?code=...` を Worker が受け取り、サーバ側でコード→トークン交換を行い `Set-Cookie` を発行する。
  - フラグメント受け取り（Implicit/fragment fallback）
    - 一部プロバイダ設定ではトークンが URL フラグメントで返ることがあるため、Worker はフラグメント捕捉用の HTML を返す。HTML は JS でフラグメントをパースして `POST /api/auth/set_tokens` を実行する（これで HttpOnly cookie を設定する）。

---

**画像（アップロード・保存・配信）仕様**
- DB 保存形式
  - DB にはファイルの「キー」のみを保存する（例: `uploads/2025/12/07/abcdef.jpg` や `r2:bucket/key` 等）。フル URL は保存しない。
  - これにより配信先（Cloudflare Images / CDN / プロキシ）を後から切り替えやすくする。
- 画像 URL 解決
  - クライアントは `getPublicImageUrl(key, opts?)`（管理コード内のユーティリティ）を使って公開 URL を生成する。
  - 実装例: `https://imagedelivery.net/<ACCOUNT>/<key>/public` または `https://public-worker.shirasame-official.workers.dev/images/<key>` など、配信方法に応じて切り替え可能。
- アップロードフロー
  1. **署名付き直接アップロード**
     - クライアントが `POST /api/images/direct-upload` を呼ぶと Worker/public-worker が署名付き PUT URL を返す。
     - クライアントはその URL に対して `PUT` でファイルをアップロード（CORS ヘッダに注意）。
     - アップロード完了後、クライアントが `POST /api/images/complete` でメタデータを送信して DB を更新する。
  2. **プロキシ経由アップロード（フォールバック）**
     - 直接 PUT に失敗する環境向けに、`POST /api/images/upload` を Worker に送り、Worker がサーバ側で保存 → DB 保存の確定を行う。
- 権限・検証
  - 画像の保存・メタ登録は管理者権限を必要とする（Worker / public-worker は Cookie を使ってユーザ権限を検証する）。

---

**配信／デプロイ構成**
- フロントエンド（管理 UI）
  - 静的ビルド（Next.js の場合 `pnpm build` → Pages or Cloudflare Pages / Vercel にデプロイ）
  - `admin.shirasame.com` でホスト（独自ドメイン）
- API プロキシ（Cloudflare Worker）
  - Route: `admin.shirasame.com/api/*` をこの Worker にバインド（重要: ドメイン全体を Worker にバインドしないことで静的資産を通す）
  - Worker は `/api/auth/*` を自前処理し、その他は `PUBLIC_WORKER_ORIGIN`（例: `https://public-worker.shirasame-official.workers.dev`）へフォワード
  - Worker secrets: `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`, `PUBLIC_WORKER_ORIGIN`, `GOOGLE_CLIENT_ID/SECRET` 等
- public-worker
  - 実際の管理 API 実装を持つ Worker（または別のホスト）。Worker が存在しない API は Supabase REST でフォールバック可能。
- 画像ストレージ
  - Cloudflare R2 / Cloudflare Images を利用。CDN 経由で配信。
- DB / 認証
  - Supabase（Postgres + Auth）。service role key は Worker のみが保持する（サーバ側操作）

---

**実装上の注意点・運用チェックリスト**
- Worker Route 設定: `admin.shirasame.com/api/*` を Worker に割り当てる（静的資産は Worker を経由しない）。
- Cookie Domain: `admin.shirasame.com` を指定して Set-Cookie を出す（サブドメインがある場合は調整）。
- SameSite: OAuth リダイレクトの都合で `Lax` や `None` の選択を検討する。
- `apiFetch()` の導入: 管理クライアント側は全て `apiFetch()` を通す（`credentials: 'include'`）
- 画像キーの正規化: DB への保存値は必ず "キーのみ" にする。フロントで余分な `uploads/` の重複が起きないようユーティリティで normalize する。
- 秘密情報管理: `SUPABASE_SERVICE_ROLE_KEY` は公開しない。Worker secret に設定する。

---

**トラブルシュート（代表ケース）**
- ケース: `/api/auth/set_tokens` に `Set-Cookie` が含まれない
  - 確認: Worker のレスポンスに `Set-Cookie` が存在するか（curl -v で確認）。
  - 原因: Domain misconfigure, SameSite が厳しすぎる, HTTP→HTTPS の差分で Secure が外れている、または Cookie を発行しているドメインが異なる。
  - 対処: `Set-Cookie` の Domain を `admin.shirasame.com` に固定、`Secure` を付与、適切な `SameSite` を設定。

- ケース: ブラウザから `fetch('/api/...')` が Cookie を送らない
  - 確認: クライアント側の `fetch` に `credentials: 'include'` があるか、古いバンドルがキャッシュされていないか。
  - 対処: `apiFetch()` に統一し、管理 UI をビルド＆再デプロイする／クライアントでキャッシュをクリアして確認。

- ケース: 画像が 403/404
  - 確認: R2 に HEAD を打って存在を確認、Cloudflare Images の設定（公開設定）を確認。
  - 対処: キーが DB と一致しているか確認、必要なら再アップロード。

---

**付録 — 代表的な cURL / PowerShell の検査コマンド**
- whoami を確認（ブラウザ代替）:
```powershell
curl.exe -v "https://admin.shirasame.com/api/auth/whoami" --cookie "sb-access-token=<TOKEN>; sb-refresh-token=<REF>"
```
- Worker の debug エンドポイント（存在する場合）:
```powershell
curl.exe -v "https://admin.shirasame.com/api/auth/debug"
```
- 画像 HEAD チェック:
```powershell
curl.exe -I "https://imagedelivery.net/<ACCOUNT>/<IMAGE_ID>/public"
```

---

必要があれば、この仕様書をベースに次の作業を行えます:
- 自動的にリポジトリ内を走査して `fetch('/api'...)` を `apiFetch()` に置換する PR を作成
- `Set-Cookie` 発行部分（Worker）の `SameSite`/`Domain` 属性を実際のケースに合わせて微調整するパッチ提案
- 代表画像キーを受け取って R2/Images の HEAD チェックを自動実行

作成しました: `docs/管理ページ_仕様書.md`

次にどれをしますか？（短く選択してください）
- A: 自動置換 PR を作る（`fetch`→`apiFetch`）
- B: `Set-Cookie` 発行箇所の属性を検査・提案する
- C: 代表画像キーで HEAD チェックを実行して結果を報告する
