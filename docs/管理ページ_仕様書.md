# 管理ページ 仕様書（実装に合わせた最新版）

この仕様書は、現在の `admin-site` 実装および `cloudflare/admin-api-proxy`（Worker）で実際に動作している挙動に合わせて更新したものです。実装者・運用者が参照できるよう、機能一覧、主要 API、認証・Cookie の取り扱い、画像のアップロード／配信フロー、デプロイ要件、運用チェック手順をまとめています。

**対象ファイル（参照）**: `admin-site/*`, `cloudflare/admin-api-proxy/*`, `shared/*`

---

## 変更点（要約）
- クライアントの管理 API 呼び出しは `apiFetch()` に統一されています（`admin-site/lib/api-client.ts`）。`apiFetch()` はデフォルトで `{ credentials: 'include', redirect: 'manual' }` を付与し、サーバ側 whoami の検証に基づく認可を前提とします。
- Cloudflare Worker（`cloudflare/admin-api-proxy`）は `/api/auth/*` を自前処理（`set_tokens`, `whoami`, OAuth callback/fragment 捕捉）し、それ以外の `/api/*` を `PUBLIC_WORKER_ORIGIN` へフォワードします。公開先に API が存在しない場合は Supabase REST を使った読み取りフォールバックがあります。
- 画像は DB に「キーのみ」を保存する方針（key-only）。フロントは `getPublicImageUrl()` を使って公開 URL を構築し、公開ページと同じ配信ロジック（`NEXT_PUBLIC_IMAGES_DOMAIN` / `IMAGES_DOMAIN` または `https://images.shirasame.com`）を用います。

 - サーバ側の厳格化（2025-12-08 追加）: 管理用途における安全性向上のため、public-worker 側で「リクエストの認証情報から user_id を推定して優先的に owner フィルタを適用する」仕組みを導入しました。これによりクライアントが `userId` を明示的に渡さなくても、HTTP ヘッダ（`Authorization: Bearer <jwt>`）や `sb-access-token` cookie のペイロードから userId を抽出して Supabase クエリに `user_id = currentUserId` を付加します。

  - 実装のポイント:
    - `public-worker/src/index.ts` に `parseJwtPayload()` と `getRequestUserId()` ヘルパを追加し、JWT または `sb-access-token` cookie から `sub` / `user_id` を抽出します（注: 現在の実装は署名検証を行わないペイロードデコードです。運用では JWK を使った署名検証を必須化してください）。
    - `/collections`, `/products`（一覧）, `/recipes`, `/tags`, `/tag-groups`, `/amazon-sale-schedules` などの主要エンドポイントで、認証済みリクエストがあればその user のデータのみを返すよう優先スコープを適用しました。未認証時は `PUBLIC_OWNER_USER_ID` の設定があればそれを使い、無ければ公開フラグ（`published=true`）や `visibility=public` を返します。
    - `admin` プロキシ（`/admin/*`）は upstream に `Authorization` ヘッダと `Cookie` を転送するように変更しました。これにより `INTERNAL_API_BASE` 側でも同一の認証情報を使って厳格な認可が行えます。

  - セキュリティ注意事項:
    - 上記のペイロードデコードは利便性のための暫定実装です。トークンの真正性を担保するため、必ず JWT の署名検証（JWK / JWKS を使った検証）か、Supabase /認証プロバイダのサーバ側セッション検証 API を使って検証してください。

---

## 機能一覧（実装ベース）
- 認証: Google OAuth（コード交換 + フラグメントフォールバック）と Supabase 認証
- サーバ権威の whoami（`GET /api/auth/whoami`）により管理 UI の初期表示・ガードを行う
- 画像アップロード: 署名付き直接アップロード（Cloudflare Images/R2）＋プロキシ経由のフォールバック
- 画像メタは DB にキーのみ保存（公開 URL は保存しない）
- 管理 CRUD API（タグ・コレクション・製品・レシピ等）は public-worker 側で実装され、Worker がフォワードする

---

## 主要 API（現在の実装に合わせた一覧）

- 認証系
  - `GET /api/auth/whoami`
    - 機能: HttpOnly Cookie（`sb-access-token`）を用いて現在のユーザーを返す。`credentials: 'include'` で呼び出すこと。
    - レスポンス: 200 + JSON（ユーザ情報） / 401（未認証）
  - `POST /api/auth/set_tokens`
    - 機能: ブラウザが受け取ったトークン（フラグメントやサーバ側交換結果）を受け取り、HttpOnly Cookie を発行する（`sb-access-token`, `sb-refresh-token`）。
    - 備考: Set-Cookie は `Domain=admin.shirasame.com; HttpOnly; Secure` を付与する想定
  - `GET /api/auth/google` / `GET /api/auth/callback`
    - 機能: Google OAuth のリダイレクト／コード交換を処理。フラグメントで返る場合は fragment-capture HTML を返し、クライアントが `/api/auth/set_tokens` にポストする流れがある。

- 画像系
  - `POST /api/images/direct-upload`
    - 機能: 署名付きアップロード URL（Cloudflare Images / R2）を返す。クライアントは取得した URL へ **multipart/form-data の POST** でファイルを送信する想定です。レスポンスは `{ result: { uploadURL, id, publicUrl?, key? } }` のような構造。
  - `POST /api/images/upload`
    - 機能: プロキシ経由でサーバ側にファイルを送り、サーバが保存して key を返す（multipart/form-data）。
  - `POST /api/images/complete`
    - 機能: 署名アップロード完了通知として、サーバにメタデータを渡して DB に登録する。

- 管理 CRUD（例）
  - `GET/PUT /api/admin/settings`、`GET/POST/PATCH/DELETE /api/admin/tags`、`/api/admin/products` など。いずれも `apiFetch()`（`credentials: 'include'`）を使って呼び出すこと。

---

## 認証・Cookie（実装の挙動）

- Cookie 名称: `sb-access-token`, `sb-refresh-token`（Supabase 互換）
- 既定の Cookie 属性（Worker の実装では少なくとも次を付与）:
  - `HttpOnly; Secure; Path=/; Domain=admin.shirasame.com; SameSite=Lax`
  - OAuth の挙動やクロスサイト POST が必要な場合、`SameSite=None` を検討する（その場合 `Secure` は必須）。
- クライアント実装: 管理 UI は `admin-site/lib/api-client.ts` の `apiFetch()` を通して API を呼び、401 が返れば `/admin/login` にリダイレクトするよう設計されています。

---

## サーバ側の挙動（認証・スコープに関する詳細）

- `whoami` フロー: ブラウザは `apiFetch()`（`credentials: 'include'`）で `/api/auth/whoami` を呼び、HttpOnly Cookie に格納された `sb-access-token` を使って現在のユーザー情報を取得することを想定しています。Worker はこの cookie を読み取り、Supabase などのバックエンドに問い合わせてユーザー情報を返す設計です。

- リクエストスコープの優先順位（public-worker 実装に合わせた運用ルール）:
  1. `Authorization: Bearer <token>` が存在し、妥当なペイロードに `sub` / `user_id` があればそれを `currentUserId` として優先的に使用。
 2. `sb-access-token` cookie（HttpOnly）に JWT があればペイロードをデコードして `currentUserId` を取得。
 3. 上記がない場合は環境変数 `PUBLIC_OWNER_USER_ID` による単一オーナー向けのスコープを適用。
 4. それもない場合は公開データ（`published=true` または `visibility=public`）のみを返す。

- Admin API プロキシ (`/admin/*`) のポリシー:
  - 公開 Worker は内部 API (`INTERNAL_API_BASE`) へ転送する際、内部キー (`x-internal-key`) に加え、`Authorization` ヘッダと `Cookie` をそのまま転送します（これにより内部 API は送られてきた認証情報を使って厳格な owner チェックを実行できます）。

---

## データベース周辺（運用・権限制御）

- RLS（Row-Level Security）推奨: Supabase などを使う場合、可能であれば RLS ポリシーを設定して `user_id` ベースのアクセス制限を強制してください。クライアント／Worker の実装だけでのフィルタはミスや将来のコードで回避されるリスクがあるため、DB 側での二重化が安全です。

- サーバ側クエリの扱い:
  - public-worker はクエリ実行前に `currentUserId` を判定し、`eq('user_id', currentUserId)` のようにクエリを補正してから実行します。
  - collection_items や recipe_pins などの関連テーブル結合時にも、参照する product/recipe が `user_id` によってスコープされていることを確認してください。

- クライアントキャッシュとの整合:
  - `admin-site/lib/db/storage.ts` にあるクライアントサイドの in-memory キャッシュは `getAll(userId?)` という形を取っています。フロントエンドでは `getCurrentUser()`（local mirror または whoami）を使って `userId` を渡す実装を推奨しますが、サーバ側での強制スコープによりクライアントが userId を渡さなくても保護されます（ただし UI の応答性向上のためクライアントでも user スコープを渡すのが望ましい）。

---

---

## 画像アップロードと配信（実装に合わせた詳細）

- DB 保存: すべて `key`（例: `images/2025/12/07/abcd1234.jpg`）のみを保存する。フル URL を DB に保存しない（key-only 方針）。
- フロントは `getPublicImageUrl(key)` を使い、`NEXT_PUBLIC_IMAGES_DOMAIN` / `IMAGES_DOMAIN` 環境変数、あるいは `https://images.shirasame.com` を用いて公開 URL を生成します。
- アップロード手順（実装の典型）:
  1. `POST /api/images/direct-upload` を呼んで署名付き URL を取得
  2. 取得した URL へ **multipart/form-data の POST** でファイルをアップロード（CORS に注意）
  3. `POST /api/images/complete` を呼んでメタを確定／DB に保存
  4. 環境やブラウザ制限で直接 PUT が使えない場合は `POST /api/images/upload` を使ってプロキシ経由で保存する
- 配信: 表示時は `buildResizedImageUrl()` や `responsiveImageForUsage()` を使い `cdn-cgi/image/...` 経路で変換配信を行う設計（Cloudflare Image Resizing を前提）。

---

## 配信・デプロイ（運用メモ）

- ホスティング: `admin-site` は静的ビルド（Next.js）を Pages / Vercel などにデプロイし、ドメイン `admin.shirasame.com` で配信することを想定。
- Worker ルート: Cloudflare 上で `admin.shirasame.com/api/*` を `admin-api-proxy` Worker に割り当てる（重要: `/*` など全トラフィックを Worker 経路にしないことで静的資産が直接配信される）。
- Worker シークレット: `SUPABASE_URL`, `SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_ROLE_KEY`, `PUBLIC_WORKER_ORIGIN`, `GOOGLE_CLIENT_ID/SECRET` などを Workers の環境に設定する。

---

## 検証手順（実行コマンド）

- ローカルでのビルド／型チェック（admin-site）:
```powershell
cd .\admin-site
pnpm install
pnpm build
```

- whoami の簡易確認（ブラウザの Console または PowerShell）:
```powershell
curl.exe -v "https://admin.shirasame.com/api/auth/whoami" --cookie "sb-access-token=<TOKEN>; sb-refresh-token=<REF>"
```

- Worker の debug（存在する場合）:
```powershell
curl.exe -v "https://admin.shirasame.com/api/auth/debug"
```

- 画像 HEAD チェック（例）:
```powershell
curl.exe -I "https://images.shirasame.com/cdn-cgi/image/width=400,format=auto/<YOUR_KEY>"
```

---

## 実装上の注意（チェックリスト）

- `apiFetch()` を管理 UI 内の API 呼び出しに必ず使う（`credentials: 'include'` を付与するため）。
- Cloudflare Worker の Route を `admin.shirasame.com/api/*` に正しく設定する（静的資産を巻き込まない）。
- `Set-Cookie` ヘッダの `Domain` を `admin.shirasame.com` にすること。
- 画像は DB に key のみ保存し、フロントは `getPublicImageUrl()` で公開 URL を解決する。

---

## 運用ノート（最近の作業）

- リポジトリ内の管理 UI 呼び出しを `apiFetch()` に統一する変更を適用済み（ブランチ: `feature/unify-admin-apiFetch-image-fix-20251208`、PR: https://github.com/Shirasame0127/shirasame-v0/pull/6）。
- `admin-site` の `pnpm build` はローカルで成功しています（2025-12-08 ローカル検証済み）。

---

## 2025-12-08: 管理 API の認証必須化（要点）

- 概要: 管理画面（ログイン画面を除く）から利用される主要な API エンドポイントについて、`Supabase /auth/v1/user` を用いたトークン検証（キャッシュ）を利用して認証を確認するよう Worker 側の実装を更新しました。未認証の場合は `401 Unauthorized` を返すポリシーを適用しています。
- 対象エンドポイント（Worker 側で強制認証が適用されたもの）:
  - `GET /collections`
  - `GET /recipes`
  - `GET /tag-groups`
  - `GET /tags`
  - `GET /amazon-sale-schedules`
  - `GET /products` （一覧取得 / 管理用途: 非公開・全件取得は認証必須。パブリック表示のために `published=true` を付けると匿名で閲覧可）

- 実装ポイント:
  - `public-worker/src/index.ts` に `verifyTokenWithSupabase()` とキャッシュを導入し、`getRequestUserId()` はまずこの検証を試みるように非同期化しました。
  - 上記エンドポイントは認証済みの `user_id` を要求し、未認証時は `401` を返します（これにより管理 UI 以外からの未認証アクセスは遮断されます）。

- 影響と注意:
  - パブリックサイトの一覧表示（例: 公開商品の一覧）をそのまま匿名で提供したい場合は、クライアント側から `?published=true` を付与するか、API を公開用途用に別ルート（公開API）を残してください。今回の変更は管理用途の保護を優先しています。
  - 本番での完全な安全性を確保するには、Worker 内での JWK による JWT 署名検証、または DB 側の RLS（Row-Level Security）を併用してください。

---

## 今回変更したファイル（主要）

- `public-worker/src/index.ts` — トークン検証キャッシュ、getRequestUserId の非同期化、管理API の認証必須化（上記エンドポイント）
- `docs/管理ページ_仕様書.md` — 本ドキュメントを更新

---

## 管理画面におけるデータ取り扱いの原則

- **目的**: 管理画面内で DB を参照・操作するすべての箇所で一貫したセキュリティと実装ルールを保証し、実装者が迷わないよう明文化する。
- **必須ルール**:
  - クライアント側では必ず現在ログイン中の `user_id` を取得すること（`/api/auth/whoami` 等での取得を推奨）。
  - すべての `db.*`（クライアントキャッシュを含む）および API 呼び出しには **明示的に** `user_id` を渡すこと。例: `db.products.getAll(userId)`、`apiFetch('/api/products', { userId })`。
  - フォールバック／refresh／create／update／delete といったすべての操作に `user_id` を必須とすること。クライアント側で省略しない。
  - 管理画面内に `user_id` を渡していない呼び出しを残さないこと（最終形は例外なく全呼び出しで `user_id` を渡す状態）。
  - `user_id` の真正性はサーバ側（Worker／upstream）でも検証すること。クライアントのみのチェックに依存しない。
- **ベストプラクティス**:
  - `getCurrentUser()` を用いてログインユーザーを取得し、取得した `user.id` を API 呼び出しに渡すパターンを標準とする。
  - 新規の管理機能を追加するときは、本節のチェックリスト（`user_id` の取得→呼び出しに付与→サーバ側で owner チェック）を実施すること。
- **違反対応**:
  - 管理画面内で `user_id` を渡していない呼び出しが見つかった場合は高優先で修正し、コードレビューでマージ拒否の根拠とする。

## 残存タスク（優先順）

- クライアント側: すべての管理ページで `db.*.getAll(userId)` を統一して渡す（未実施のページを検出して修正） — ファイルの網羅修正が必要
- 内部 API (`INTERNAL_API_BASE`) 側でのトークン検証と owner チェックの強化（Worker はヘッダ転送済みだが upstream でも検証必須）
- Worker 内で JWK を使った JWT 署名検証を実装して外部依存（/auth/v1/user）を減らす
- 統合テスト: admin-site と public-worker を組み合わせた動作検証（ログイン、一覧、詳細、未認証ブロック）

---

必要なら、これら残タスクのいずれかから作業を続けます。どれを優先しますか？

---

もしこの仕様書のさらに細かい箇所（Cookie の `SameSite` 設定、Worker の具体的なフォワードルール、あるいは `getPublicImageUrl()` のドメイン決定ロジック）を実際の本番挙動に合わせて微調整したければ、どの点を優先するか指示してください。次は以下を実行できます:

- A: Worker の `Set-Cookie` ヘッダ属性を実際の本番リダイレクトフローに合わせて調整するパッチを作成
- B: 代表画像キーを受け取って私が HEAD を自動で叩き、配信状況（200/403/404 と `cf-cache-status`）を報告
- C: PR にビルド結果・変更点の詳細な説明を追加してレビュー向けに整備

